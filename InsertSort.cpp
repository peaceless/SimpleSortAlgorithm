void InsertSort(ElemType A[],int n) {
	int i,j;
	for(i = 2;i<=n;i++) {	//依次将A【2】~A【n】插入到前面已排序序列
		if(A[i].key < A[i-1].key) {		//若A【i】的关键码小于其前驱，需将A【i】插入有序表
			A[0] = A[i]	;	//复制为哨兵，A【0】不存放元素
			for(j = i-1;A[0].key < A[j].key;--j)	//从后往前查找带插入位置
				A[j+1] = A[j];	//向后挪位置
		}
		A[j+1] = A[0];	//复制到插入位置
	}
}
/*
	空间效率：使用常数单元，空间复杂度为O（1）
	时间效率：最好情况下，即表中元素已有序，时间复杂度为O（n）
			 最坏情况下，即表中元素逆序，总的移动次数为Σ（i = 2~n）（i+1）
			 平均比较次数和总的移动次数为n²/4
/*