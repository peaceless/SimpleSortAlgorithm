void ShellSort(ElemType A[],int n)
{
	//对顺序表作希尔插入排序，本算法和直接插入排序相比，作了以下修改
	//1.前后记录位置的增量是dk，不是1
	//2.r[0]知识暂存单元，不是哨兵，当j<=0,插入位置已到
	for(dk = n/2;dk >= 1;dk /= 2) {		//步长变化
		for(i = dk+1;i<=n;++i){
			if(A[i].key < A[i-dk].key){	//需将A【i】插入有序增量字表
				A[0] = A[i];			//暂存在A【0】
				for(j = i-dk;j > 0 && A[0].key < A[j].key;j -= dk)
					A[j+dk] = A[j];		//记录后移，查找插入位置
				A[j+dk] = A[0];			//插入
			}
		}
	}
}
/*
 * 空间效率：仅使用常数个辅助单元，故空间复杂度为O(1)；
 * 时间效率：依赖于增量序列的函数，当n在某个特定范围时，希尔排序的时间复杂度约为O(n1.3)，
 * 最坏情况是O(n²)
 */